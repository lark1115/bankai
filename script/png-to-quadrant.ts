/**
 * PNG → Quadrant block character converter (disposable script)
 *
 * Usage: bun run script/png-to-quadrant.ts [input.png] [--width N]
 *
 * Converts a PNG image to Unicode Quadrant block characters (U+2580-U+259F).
 * Each terminal cell represents a 2×4 pixel block (2 wide × 4 tall due to
 * cell aspect ratio correction: terminal cells are ~2:1 height:width).
 */

import sharp from "sharp";
import { writeFileSync } from "node:fs";
import { resolve, dirname } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = dirname(fileURLToPath(import.meta.url));

// Quadrant lookup: 4 bits → Unicode character
// Bit order: top-left(3), top-right(2), bottom-left(1), bottom-right(0)
const QUADRANT: Record<number, string> = {
  0b0000: " ",
  0b1000: "▘",
  0b0100: "▝",
  0b1100: "▀",
  0b0010: "▖",
  0b1010: "▌",
  0b0110: "▞",
  0b1110: "▛",
  0b0001: "▗",
  0b1001: "▚",
  0b0101: "▐",
  0b1101: "▜",
  0b0011: "▄",
  0b1011: "▙",
  0b0111: "▟",
  0b1111: "█",
};

async function main() {
  const args = process.argv.slice(2);
  const widthIdx = args.indexOf("--width");
  const targetCellWidth = widthIdx >= 0 ? parseInt(args[widthIdx + 1]) : 50;

  // Skip --width and its value when looking for input path
  const skipSet = new Set<number>();
  if (widthIdx >= 0) { skipSet.add(widthIdx); skipSet.add(widthIdx + 1); }
  const inputPath =
    args.find((a, i) => !a.startsWith("--") && !skipSet.has(i)) ??
    "/Users/apollo/Downloads/yuji-mai_卍解.png";

  // Target pixel width = cellWidth * 2 (each cell = 2px wide)
  const targetPxWidth = targetCellWidth * 2;

  // Load and process image
  const img = sharp(inputPath);
  const metadata = await img.metadata();
  if (!metadata.width || !metadata.height) throw new Error("Cannot read image dimensions");

  // Calculate target height maintaining aspect ratio with cell aspect correction
  // cellAspect = 2 means cells are twice as tall as wide
  // So we halve the pixel height to compensate
  const scale = targetPxWidth / metadata.width;
  const targetPxHeight = Math.round((metadata.height * scale) / 2);

  // Ensure dimensions are multiples of 2 (for 2x2 cell blocks)
  const w = Math.floor(targetPxWidth / 2) * 2;
  const h = Math.floor(targetPxHeight / 2) * 2;

  const { data, info } = await img
    .resize(w, h, { fit: "fill" })
    .grayscale()
    .raw()
    .toBuffer({ resolveWithObject: true });

  // Threshold: pixel < 128 = ink (1), else blank (0)
  const bitmap: number[] = new Array(info.width * info.height);
  for (let i = 0; i < bitmap.length; i++) {
    bitmap[i] = data[i] < 128 ? 1 : 0;
  }

  // Convert to Quadrant characters
  const lines: string[] = [];
  const cellRows = info.height / 2;
  const cellCols = info.width / 2;

  for (let cy = 0; cy < cellRows; cy++) {
    let line = "";
    for (let cx = 0; cx < cellCols; cx++) {
      const px = cx * 2;
      const py = cy * 2;
      const tl = bitmap[py * info.width + px];       // top-left
      const tr = bitmap[py * info.width + px + 1];   // top-right
      const bl = bitmap[(py + 1) * info.width + px]; // bottom-left
      const br = bitmap[(py + 1) * info.width + px + 1]; // bottom-right
      const bits = (tl << 3) | (tr << 2) | (bl << 1) | br;
      line += QUADRANT[bits];
    }
    lines.push(line);
  }

  // Trim trailing whitespace per line, then trim empty leading/trailing lines
  const trimmed = lines.map((l) => l.trimEnd());
  let start = 0;
  while (start < trimmed.length && trimmed[start].trim() === "") start++;
  let end = trimmed.length - 1;
  while (end > start && trimmed[end].trim() === "") end--;
  const result = trimmed.slice(start, end + 1);

  // Generate TypeScript source
  const tsLines = result.map((l) => {
    // Escape backticks and backslashes for template literal safety
    const escaped = l.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\$/g, "\\$");
    return `  "${escaped}",`;
  });

  const tsContent = `// Auto-generated by script/png-to-quadrant.ts — do not edit manually
export const BANKAI_ART: readonly string[] = [
${tsLines.join("\n")}
] as const;
`;

  const outPath = resolve(__dirname, "../src/ui/bankai-art.ts");
  // Ensure output directory exists
  const { mkdirSync } = await import("node:fs");
  mkdirSync(dirname(outPath), { recursive: true });
  writeFileSync(outPath, tsContent, "utf-8");
  console.log(`Generated ${outPath}`);
  console.log(`  ${result.length} rows × ${cellCols} cols`);

  // Preview in terminal
  console.log("\nPreview:");
  for (const line of result) {
    console.log(line);
  }
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
